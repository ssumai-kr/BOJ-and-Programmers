// const fs = require('fs');
// const input = fs.readFileSync(0).toString().trim().split('\n');

//환경이 생쥐의 몸집에 얼마나 영향을 주는가 2가지 대조군
//밝은 A 어두운 B
//N마리의 새끼 쥐, 1달의 시간
// [X-2, X+2] 구간에 속하는 쥐가 가장 많을 때, 그 중 가장 작은 X 값이 대표 값이다.
// [4 1 3 9 5 11 2]  X = 3이면, [1 ~ 5] 구간에 속하는 쥐 -> 4 1 3 5 2
// 이 X값이 가장 많은 쥐를 포함한 값이므로 대푯값은 3이 된다.

//이 두 대조군의 대푯값의 차이를 구하시오.
// A대표값이 B대표값보다 클 것으로 예상

const fs = require('fs');
const input = fs.readFileSync(0).toString().trim().split(/\s+/);

const N = parseInt(input[0]);
// 데이터를 나누어 숫자로 변환
const A_mice = input.slice(1, N + 1).map(Number);
const B_mice = input.slice(N + 1, 2 * N + 1).map(Number);

function getRepresentative(mice) {
    const MAX_SIZE = 100000;
    // 몸집별 빈도수 체크용 배열 (1 ~ 100,000)
    const freq = new Array(MAX_SIZE + 1).fill(0);
    for (const size of mice) {
        freq[size]++;
    }

    let maxCount = -1;
    let bestX = 0;

    // 초기 윈도우 설정: X=1일 때 [X-2, X+2] 즉, [-1, 0, 1, 2, 3]
    // 1보다 작은 인덱스는 무시하므로 1, 2, 3번 인덱스의 합으로 시작
    let currentSum = (freq[1] || 0) + (freq[2] || 0) + (freq[3] || 0);

    for (let x = 1; x <= MAX_SIZE; x++) {
        // x의 범위 [x-2, x+2]에 포함된 쥐의 수 계산
        // x가 1씩 증가할 때마다 왼쪽 끝(x-3)은 빠지고 오른쪽 끝(x+2)은 들어옴
        if (x > 1) {
            const outIndex = x - 3;
            const inIndex = x + 2;
            if (outIndex >= 1) currentSum -= freq[outIndex];
            if (inIndex <= MAX_SIZE) currentSum += freq[inIndex];
        }

        // 최댓값 갱신 (가장 작은 X를 구해야 하므로 '>' 사용)
        if (currentSum > maxCount) {
            maxCount = currentSum;
            bestX = x;
        }
    }
    return bestX;
}

const Ax = getRepresentative(A_mice);
const Bx = getRepresentative(B_mice);

// 결과 출력
console.log(`${Ax} ${Bx}`);
console.log(Ax > Bx ? "good" : "bad");